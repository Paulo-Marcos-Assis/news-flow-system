from abc import ABC, abstractmethod
import os
import json
import traceback
import sys
from service_essentials.utils.logger import Logger
from service_essentials.exceptions.fail_queue_exception import FailQueueException


class BasicProducerConsumerService(ABC):
    def __init__(self):
        """
        Initialize the service with input, output, and fail queues using a single QueueManager.
        """
        self.service_name = os.getenv("SERVICE_NAME", "service_local_test")
        self.input_queue = "mock_input"
        self.output_queue = "mock_output"
        self.fail_queue = "mock_fail"
        self.error_queue = "mock_error"
        self.logger = Logger(self,log_to_console=True)

        mock_data_file_name = "mock_data.json"
        # Get the directory of the main script
        main_script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        mock_data_file_path = os.path.join(main_script_dir,mock_data_file_name)
        try:
            with open(mock_data_file_path, 'r') as file:
                self.input_message = json.load(file)
            self.logger.info("Mock data loaded successfully:")
        except FileNotFoundError:
            self.logger.error(f"File with mock data not found! Its path should be {mock_data_file_path}")
        except json.JSONDecodeError as e:
            self.logger.error("Failed to decode mock data JSON!")

    def start(self):
        """
        Start consuming messages from the input queue and handle processing.
        """
        self.logger.info(f"Start consuming input messages...")
        for i,message in enumerate(self.input_message):
            self.logger.info(f"Processing message #{i}: {message}")
            try:
                result = self.process_message(message)
                try:
                    json_message = json.dumps(result,ensure_ascii=False)
                    self.logger.info(f"Result generated by process_message:\n{json_message}")
                except (TypeError, ValueError) as e:
                    self.logger.error(f"Error: Unable to serialize the processors result to JSON - {e}\n Not sending ack to this message.")
            except FailQueueException as e:
                self.logger.info(f"FailQueueException: {e}")
                fail_payload = json.dumps({"original_message": message,"error": str(e)})
                self.logger.info(f"Failed message to be sent to fail_queue:\n{fail_payload}")
            except Exception as e:
                self.logger.error(f"Unhandled Exception: {e}")
                traceback_payload = json.dumps({
                    "original_message": message,
                    "error": str(e),
                    "stacktrace": traceback.format_exc()
                })
                self.logger.error(f"Stacktrace: {traceback.format_exc()}")
                self.logger.error(f"Unhandled exception details to be sent to error_queue:\n{traceback_payload}")

    @abstractmethod
    def process_message(self, message):
        """
        Process the message (logic specific to the service).
        """
        # Example placeholder logic for sending the message to fail queue
        #raise FailQueueException("Message contains 'fail', routing to fail queue.")
        pass